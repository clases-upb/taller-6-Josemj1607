/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.Arrays;
import java.util.Scanner;



public class App { 

    public static String ruta = "app\\src\\main\\java\\org\\example\\palabras aleatorias.txt";
    public static final int MAX = 15, MIN = 4, UNO = 1, CERO = 0, ASCII1 = 65, ASCII2 = 122;
    public static Scanner teclado = new Scanner(System.in);
    public static int [][]m_numeros;
    public static String [] v_Strings;
    public static int [] v_numeros;
    public static String Verde = "\u001B[32m",
    Rojo = "\u001B[31m",
    Negro = "\u001B[30m",
    Amarillo = "\u001B[33m",
    Azul = "\u001B[34m",
    Purpura = "\u001B[35m",
    CYAN = "\u001B[36m",
    Blanco = "\u001B[37m",
    RESET = "\u001B[0m";
    
  

    public static void main(String[] args) {
        try {  
            String opcion;
            String posicion_s;
            String posicion_n;
            String reemplazo_s;
            String reemplazo_n;
            String elemento_s;
            String elemento_n;
            String op;
    
            v_Strings = V_Strings_lleno();
            v_numeros = V_numeros_lleno();
    
            do {
                System.out.println("\n Ingrese por favor su opcion para manipular vectores \n");
                System.out.println("a. Recorrer secuencialmente");
                System.out.println("b. Actualizar");
                System.out.println("c. Añadir");
                System.out.println("d. Borrar");
                System.out.println("e. Ordenar el vector");
                System.out.println("f. Búsqueda");
                System.out.println("g. finalizar");
                System.out.println();
    
                opcion = teclado.next();
    
                switch (opcion.charAt(0)) {
                    case 'a':  
                        do { 
                            System.out.println("\n Ingrese true para recorrer el vector de manera acendente, false de manera decendente. Pulse 0 para salir de la opcion a");
                            opcion = teclado.next();
    
                            System.out.println(Recorrer_secuencialmente(opcion.toLowerCase()));
    
                        } while (opcion.charAt(0) != '0');
                        break;
    
                    case 'b':
                        do { 
                            opcion = "true";
                            System.out.println(Recorrer_secuencialmente(opcion));
    
                            System.out.println("\n ¿Qué posición desea cambiar para el vector de Strings?");
                            posicion_s= teclado.next();
                            System.out.println("\n ¿Qué posición desea cambiar para el vector de números?");
                            posicion_n = teclado.next();
                            System.out.println("\n ¿Por cuál caractér desea reemplazar en la posición elegida del vector de Strings?, procure no exceder el tamaño -1");
                            reemplazo_s = teclado.next();
                            System.out.println("\n ¿Por cuál caractér desea reemplazar en la posición elegida del vector de números?, procure no exceder el tamaño -1");
                            reemplazo_n = teclado.next();
    
                            System.out.println(Actualizar(posicion_s, posicion_n, reemplazo_s, reemplazo_n));
    
                            System.out.println("\n si desea finalizar la opción b pulse 0, si desea continuar pulse cualquier otra tecla");
                            opcion = teclado.next();
    
                        } while (opcion.charAt(0) != '0');
                        break;
    
                    case 'c':
                        do { 
                            opcion = "true";
                            System.out.println("Este es el vector que vamos a operar\n");
                            System.out.println(Recorrer_secuencialmente(opcion));
    
                            System.out.println("\n\n¿Qué elemento desea añadir al vector de Strings? ");
                            elemento_s = teclado.next();
                            System.out.println("\n ¿Qué elemento desea añadir al vector de números enteros?");
                            elemento_n = teclado.next();
    
                            System.out.println(Añadir(elemento_s, elemento_n));
    
                            System.out.println("\n si desea finalizar la opción c pulse 0, si desea continuar pulse cualquier otra tecla");
                            opcion = teclado.next();
    
                        } while (opcion.charAt(0)!= '0');
                        break;
    
                    case 'd':  
                        do { 
                            opcion = "true";
                            System.out.println("Este es el vector que vamos a operar\n");
                            System.out.println(Recorrer_secuencialmente(opcion));
    
                            System.out.println("\n\n¿Qué posición desea borrar al vector de Strings? ");
                            elemento_s = teclado.next();
                            System.out.println("\n¿Qué posición desea borrar al vector de números enteros?");
                            elemento_n = teclado.next();
    
                            System.out.println(Borrar(elemento_s, elemento_n));
    
                            System.out.println("\n si desea finalizar la opción c pulse 0, si desea continuar pulse cualquier otra tecla");
                            opcion = teclado.next();
    
                        } while (opcion.charAt(0) != '0');
                        break;
    
                    case 'e':  
                        do {
                            opcion = "true";
                            System.out.println("Este es su vector:\n\n");
                            System.out.println(Recorrer_secuencialmente(opcion));
    
                            System.out.println("\n\n¿Cómo desea ordenarlo?");
                            System.out.println("1. Acendentemente\n2. Descendentemente");
                            op = teclado.next();
    
                            System.out.println(Ordenar_Ascendente_Descendente(op));
    
                            System.out.println("\n\n0. Para salir de la opción e, si quiere continuar pulse cualquier otra tecla");
                            opcion = teclado.next();
    
                        } while (opcion.charAt(0) != '0');
                        break;
    
                    case 'f':  
                        do { 
                            opcion = "true";
                            System.out.println("Este es su vector:\n\n");
                            System.out.println(Recorrer_secuencialmente(opcion));
    
                            System.out.println("¿De cuál elemento desea conocer la posición en el vector de Strings?");
                            elemento_s = teclado.next();
    
                            System.out.println("¿De cuál elemento desea conocer la posición en el vector de números?");
                            elemento_n = teclado.next();
    
                            System.out.println(Busqueda(elemento_s, elemento_n));
    
                            System.out.println("\n0. Para salir de la opción f, si quiere continuar pulse cualquier otra tecla");
                            opcion = teclado.next();
                        } while (opcion.charAt(0) != '0');
                        break;  
                }
            } while (opcion.charAt(0) != 'g');
    
            System.out.println("Muchas gracias por usar el programa, tenga un feliz día");
    
            teclado.close();

        } catch (Exception e) {
            System.out.println("Ocurrió un error \n"+ e.toString());
        }

    }
    
    /*
     * 1. Implemente un programa en java donde inserte elementos en dos vectores
     * globales de tamaños aleatorios y de contenido aleatorio (uno numérico y otro
     * de Strings). Considere dejar espacios libres en los vectores.
     * 
     * Desde un menú en el programa principal debe considerar cada opción para
     * llamar las siguientes funciones que también debe programar:
     * 
     * a. Recorrer secuencialmente (recibe un true cuando va del primero al último y
     * un false cuando va del último al primero)
     * • De primer elemento a último elemento: Imprime desde el primer elemento
     * hasta el último del vector dado en el parámetro de entrada.
     * • De último elemento al primer elemento: Imprime desde el último elemento
     * hasta el primero del vector dado en el parámetro de entrada.
     * 
     * b. Actualizar: recibe la posición que va a actualizar y el elemento. Al final
     * imprime el vector actualizado.
     * 
     *  c. Añadir: después del último: recibe el elemento que va a añadir. Al final
     * imprime el vector actualizado.
     *
     * d. Borrar: Recibe la posición donde del elemento que va a borrar.
     * 
     * e. Ordenar el vector:
     * • Ascendentemente.
     * • Descendentemente.
     * 
     * f. Búsqueda: Recibe como parámetro el elemento a buscar y devuelve un String
     * separado por el carácter '-', mostrando las posiciones donde se encuentra el
     * elemento.
     */

    /*
     * 2. Escriba un algoritmo que calcule aleatoriamente N temperaturas, las lleve
     * a un vector y luego calcule su media, cuántas temperaturas están por encima
     * de la media y cuántas por debajo.
     */
     
     public static void Temperaturas() throws Exception {
        try {
            final byte sesenta = 60, veinte = 20, uno = 1;
            int alea = (int) (Math.random() * (veinte) + uno);
            int temp_debajo = 0, temp_encima = 0, temp_en_la_media = 0, suma = 0;
            float media = 0;
            float[] v_temp = new float[alea];
    
           
            System.out.println("Estas son todas las temperaturas registradas:\n");
            for (int i = 0; i < v_temp.length; i++) {
                v_temp[i] = (float) (Math.random() * (sesenta + uno));
                suma += v_temp[i];
                System.out.print(v_temp[i] + "\t");
            }
            
            double cant_elem = v_temp.length;
    
            media = (float) (suma / cant_elem);
    
            for (int j = 0; j < v_temp.length; j++) {
                if (v_temp[j] < media) {
                    temp_debajo++;
                } else if (v_temp[j] > media) {
                    temp_encima++;
                } else {
                    temp_en_la_media++;
                }
            }
    
            System.out.println("\n\nLa temperatura media calculada es de: " + media + "\n\nHay " + temp_encima + " temperaturas por encima de la temperatura media\n" +
                    "\nHay " + temp_debajo + " temperaturas por debajo de la media\n" + "\nHay " + temp_en_la_media + " justo en la media");
    
        } catch (Exception e) {
            throw new Exception("Error en la función Temperaturas\n" + e.toString());
        }
    }
    
    /*
     * 3. Cargue un vector a partir de un archivo de palabras, con mínimo 10
     * palabras. Ordene el vector de manera ascendente y luego de forma descendente.
     * 
     * Escriba el vector inicial sin ordenar, los vectores ordenados.
     */

     public static void Ordenar(String ruta_arch) throws IOException {
        String[] palabras = new String[10];
        String temp = "";
        int contador = 0;
        
        try {
            FileReader fr_palabras = new FileReader(ruta_arch);
            BufferedReader br_palabras = new BufferedReader(fr_palabras);
    
            String linea = br_palabras.readLine();
            if(linea == null){
                System.out.println("Archivo vacío");
            }
            else{
                while (linea !=  null) {
                    if (contador == palabras.length) {
                        palabras = Arrays.copyOf(palabras, palabras.length + 5);
                    }
                    palabras[contador] = linea;
                    contador++;
                }
    
                if (contador < 10) {
                    System.out.println("El archivo debe contener al menos 10 palabras.");
                } else {
                    palabras = Arrays.copyOf(palabras, contador);
    
                    System.out.println("Vector inicial (sin ordenar):");
                    for (int pos = 0; pos < palabras.length; pos++) {
                        System.out.println(palabras[pos]);
                    }
    
                    Arrays.sort(palabras);
                    System.out.println("\nVector ordenado de forma ascendente:");
                    for (int i = 0; i < palabras.length; i++) {
                        System.out.println(palabras[i]);
                    }
    
                    System.out.println("\n\nVector ordenado de forma descendente:");
                    for (int indice = 0; indice < palabras.length / 2; indice++) {
                        temp = palabras[indice];
                        palabras[indice] = palabras[palabras.length - 1 - indice];
                        palabras[palabras.length - 1 - indice] = temp;
                    }
    
                    for (int indice = 0; indice < palabras.length; indice++) {
                        System.out.println(palabras[indice]);
                    }
                }
            }
            br_palabras.close();
        } catch (IOException e) {
            throw new IOException("Error la funcion Ordenar\n" + e.getMessage());
        }
    }
      
    /*
     * 4. Escriba un algoritmo que cree un vector de N elementos (el N es dado por
     * el usuario) de números short aleatorios positivos mayores que cero, y luego
     * le pregunte al usuario qué posición quiere eliminar. Luego por un menú
     * presente las opciones: Dejar la casilla en 0 o desplazar los elementos de
     * manera que el cero quede en la última posición del vector. Después de la
     * operación mostrará el vector cómo va quedando y volverá a preguntar qué
     * posición quiere borrar y mostrará nuevamente el menú. En el menú aparecerá la
     * opción para terminar el programa.
     */

     public static void Eliminar_Pos() throws Exception {
        try {
            final byte cero = 0, cien = 100;
            
            System.out.println("Ingrese por favor el tamaño del vector: ");
            short opcion1 = teclado.nextShort();
            short opcion2;
    
            if (opcion1 > cero) {
    
                short[] v_Numeros = new short[opcion1];
    
                for (int i = 0; i < v_Numeros.length; i++) {
                    v_Numeros[i] = (short) ((Math.random() * (cien)+1));
                }
    
                do {
                    System.out.println("Ingrese por favor la posición a eliminar en el vector. Si ingresa un número no válido o ingresa -1, el programa se finaliza automáticamente");
                    opcion1 = teclado.nextShort();
    
                    if (opcion1 >= cero && opcion1 < v_Numeros.length) {
    
                        do {
    
                            System.out.println("\n\n1. Dejar la casilla en 0 ");
                            System.out.println("2. Desplazar los elementos de manera que el cero quede en la última posición del vector");
                            System.out.println("3. Volver al menú anterior (Si ingresa un número inválido regresará al menú anterior también)");
                            opcion2 = teclado.nextShort();
    
                            if (opcion2 >= cero) {
    
                                switch (opcion2) {
                                    case 1:
                                        System.out.println("Este es el vector antes de ejecutar los cambios solicitados:\n");
                                        for (int x = 0; x < v_Numeros.length; x++) {
                                            System.out.print(v_Numeros[x] + "\t");
                                        }
    
                                        v_Numeros[opcion1] = 0;
                                        System.out.println("\nEste es su vector dejando la casilla de la posición " + opcion1 + " en 0:\n");
    
                                        for (int j = 0; j < v_Numeros.length; j++) {
                                            System.out.print(v_Numeros[j] + "\t");
                                        }
    
                                        break;
    
                                    case 2:
                                        System.out.println("Este es el vector antes de actualizar su valor:\n");
                                        for (int n = 0; n < v_Numeros.length; n++) {
                                            System.out.print(v_Numeros[n] + "\t");
                                        }
    
                                        
                                        for (int n = opcion1; n < v_Numeros.length - 1; n++) {
                                            v_Numeros[n] = v_Numeros[n + 1];  
                                        }
                                        v_Numeros[v_Numeros.length - 1] = 0;  
    
                                        System.out.println("\n\nEste es su vector con la posición eliminada al final:\n");
    
                                        for (int pos = 0; pos < v_Numeros.length; pos++) {
                                            System.out.print(v_Numeros[pos] + "\t");
                                        }
    
                                        break;
    
                                }
    
                            } else {
                                opcion2 = 3;
                            }
    
                        } while (opcion2 != 3);
    
                    } else {
                        opcion1 = -1;
                        System.out.println("Ingresaste una posición inválida, el programa finalizará.");
                    }
    
                } while (opcion1 != -1);
    
                Thread.sleep(2000);
                System.out.println("\nHa finalizado el programa, tenga un excelente día.");

                teclado.close();
    
            } else if (opcion1 <= cero) {
                System.out.println("Ingresaste un tamaño no permitido para los arreglos, por favor intenta de nuevo.");
                teclado.close();
            }
    
        } catch (Exception e) {
            throw new Exception("Ha ocurrido un error en la función Eliminar_Pos\n" + e.toString());
        }
    }
    
    /*
     * 5. Escriba un algoritmo para convertir un número decimal en un número
     * hexadecimal, apoyado en vectores.
     */
    public static void convertirDecimalAHexadecimal() throws Exception {

        try {
            int numeroDecimal;
            String[] hexadecimales = new String[100]; 
            int indice = 0;
    
            System.out.println("Ingrese un número decimal para convertirlo a hexadecimal:");
            numeroDecimal = teclado.nextInt();
            teclado.close();
    
            if (numeroDecimal < 0) {
                System.out.println("Por favor, ingrese un número decimal positivo.");
                
            } else {
                while (numeroDecimal > 0) {
                    int residuo = numeroDecimal % 16;
                    String digitoHexadecimal;
    
                    if (residuo < 10) {
                        digitoHexadecimal = String.valueOf(residuo);
                    } else {
                        digitoHexadecimal = String.valueOf((char) ('A' + (residuo - 10)));
                    }
    
                    hexadecimales[indice] = digitoHexadecimal;
                    numeroDecimal /= 16;
                    indice++;
                }
    
                System.out.print("El número en hexadecimal es: ");
                for (int i = indice - 1; i >= 0; i--) {
                    System.out.print(hexadecimales[i]);
                }
                System.out.println();
            }
    
        } catch (Exception e) {
            throw new Exception("Error en la función convertirDecimalAHexadecimal: " + e.toString());
        }
    }
    
    /*
     * 6. Escriba un algoritmo que solicite al usuario el orden de una matriz
     * cuadrática, implemente su matriz transpuesta (investiga qué es) y la imprima.
     */

    public static void M_transpuesta() throws Exception {
        try {
            int fil, col;
    
            System.out.println("Ingrese por favor el número de filas que desea para su arreglo");
            fil = teclado.nextInt();
    
            System.out.println("\nAhora ingrese por favor el número de columnas que desea para su arreglo");
            col = teclado.nextInt();
    
            final byte cero = 0, nueve = 9, dos = 2, uno = 1;
            String txt = "";
    
            if (fil > cero && col > cero) {
                m_numeros = new int[fil][col];
                int[][] m_transpuesta = new int[col][fil];  
    
               
                System.out.println("Esta es su matriz original \n");
    
                for (int i = 0; i < m_numeros.length; i++) {
                    for (int j = 0; j < m_numeros[i].length; j++) {
                        m_numeros[i][j] = (int) (Math.random() * (nueve - dos + uno) + dos);
                        m_transpuesta[j][i] = m_numeros[i][j];
                        txt += m_numeros[i][j] + "\t";
                    }
                    txt += "\n";
                }
    
                System.out.println(txt);
                txt = "";
    
                System.out.println("\nAhora, esta es su matriz transpuesta \n");
    
                for (int x = 0; x < m_transpuesta.length; x++) {
                    for (int y = 0; y < m_transpuesta[x].length; y++) {
                        txt += m_transpuesta[x][y] + "\t";
                    }
                    txt += "\n";
                }
                System.out.println(txt);
            }
    
        } catch (Exception e) {
            throw new Exception("Error");
        }
    }
    
    /*
     * 7. Escriba un algoritmo que calcule el producto y la división. Los operandos
     * serán la suma de elementos de la diagonal principal y la suma de los
     * elementos de la diagonal secundaria. Los elementos de la matriz deben ser
     * llenados usando la función random para calcular números aleatorios entre 10 y
     * 100.
     */

      public static void Producto_Division() throws Exception{
        try {

            DecimalFormat formato_cociente = new DecimalFormat("#.###");
            DecimalFormat formato_producto = new DecimalFormat("#,###,###");
            final int CIEN = 100, DIEZ = 10;
            double producto = 0, secundaria = 0, principal = 0, cociente;

            String txt = "";
            
            //dado que la matriz tiene diagonales entonces debe ser cuadrática, se le asignará un tamaño predeterminado
            m_numeros = new int[5][5];

            
            for(int i = 0; i < m_numeros.length; i ++){

                for(int j = 0; j < m_numeros[i].length; j++){

                    m_numeros[i][j] = (int)(Math.random() * (CIEN - DIEZ +1)+ DIEZ);
                    txt +=  m_numeros[i][j] + "\t";

                }
                txt += "\n";
                principal += m_numeros[i][i];
                secundaria += m_numeros[i][m_numeros.length -1 -i];
            }
            producto = principal * secundaria;
            cociente = principal/secundaria;
           
            

            System.out.println(principal + "\t" + secundaria);

            System.out.println("Esta es la matriz que vamos a operar\n" + txt + 
            "\neste es el producto de sus diagonales: "+ formato_producto.format(producto) +"\ny este es cociente de sus diagonales: "+ formato_cociente.format(cociente));


        } catch (Exception e) {
            throw new Exception("Ha ocurrido un error en la funcion Producto_Division\n" + e.toString());
        }



      }
    
    /*
     * 8. Escriba un algoritmo que llene de manera aleatoria una matriz de 100 filas
     * por 3 columnas con Xs y Os. Y mediante un vector cuente el número de Xs y Os
     * en cada fila. Imprima la matriz antes de llenarla, luego de llenarla y el
     * vector con el resultado.
     */
      public static void Llenar_Xs_Os() throws Exception{
        try {

            String [][] m_xs_os = new String[100][3];
            String [] v_contador = new String[2];
            String txt = "";
            final int dos = 2, uno = 1;
            int cont_Xs = 0, cont_Os = 0, alea = 0;


            System.out.println("Esta es la matriz antes de llenarse\n");

            for (int i = 0; i < m_xs_os.length; i++) {

                for (int j = 0; j < m_xs_os[i].length; j++){
                    System.out.print(m_xs_os[i][j] + "\t");

                }
                System.out.println();
                
            }

            for(int fil = 0; fil < m_xs_os.length; fil++){

                for(int col = 0; col < m_xs_os[fil].length; col++){
                    alea = (int)(Math.random()*(dos)+uno);

                    if(alea == uno){
                        m_xs_os[fil][col] = "X";
                        cont_Xs++;
                    }
                    else if(alea == dos){
                        m_xs_os[fil][col] = "O";
                        cont_Os++;
                    }

                    txt += m_xs_os[fil][col] +"\t";

                }
                txt += "\n";
            }
            System.out.println("\nEsta es nuestra matriz completamente llena\n\n"+txt+"\n");

            v_contador[0] = "La cantidad de Xs en la matriz es de: " + cont_Xs + " y";
            v_contador[1] = "La cantidad de Os en la matriz es de: " + cont_Os;

            System.out.println("Estos son los resultados solicitados dentro del vector\n");
            for (int x = 0; x < v_contador.length; x++){
                System.out.print(v_contador[x]+" ");
            }
                
 
        } catch (Exception e) {
            throw new Exception("Ha ocurrido un error en la funcion Llenar_Xs_Os\n" + e.toString());
        }

      }

    /*
     * 9. Llene una matriz de 5x5 con números aleatorios entre 1 y 9. En un vector
     * adicional, calcule la cantidad de números repetidos por cada fila y en otro
     * vector la cantidad de números repetidos de cada columna.
     */
     public static void Repetidos() throws Exception {
        try {
            int[][] m_aleatorios = new int[5][5];
            byte[] v_fil = new byte[5]; 
            byte[] v_col = new byte[5];
            int num1 = 0; 
    
            final byte nueve = 9, uno = 1;
    
           
            System.out.println("Esta es nuestra matriz de números aleatorios:\n");
            for (int i = 0; i < m_aleatorios.length; i++) {
                for (int j = 0; j < m_aleatorios[i].length; j++) {
                    m_aleatorios[i][j] = (int) (Math.random() * nueve + uno);
                    System.out.print(m_aleatorios[i][j] + "\t");
                }
                System.out.println();
            }
    
            
            boolean[] repetidosFila = new boolean[10];
            for (int fil = 0; fil < m_aleatorios.length; fil++) {
               
                for (int col = 0; col < repetidosFila.length; col++) {
                    repetidosFila[col] = false;
                }
    
                for (int col2 = 0; col2 < m_aleatorios[fil].length; col2++) {
                    num1 = m_aleatorios[fil][col2];
                    if (repetidosFila[num1]) {
                        v_fil[fil]++; 
                    } else {
                        repetidosFila[num1] = true; 
                    }
                }
            }
    
            
            boolean[] repetidosColumna = new boolean[10]; 
            for (int col3 = 0; col3 < m_aleatorios[0].length; col3++) {
                
                for (int k2 = 0; k2 < repetidosColumna.length; k2++) {
                    repetidosColumna[k2] = false;
                }
    
                for (int fila3 = 0; fila3 < m_aleatorios.length; fila3++) {
                    int num2 = m_aleatorios[fila3][col3];
                    if (repetidosColumna[num2]) {
                        v_col[col3]++; 
                    } else {
                        repetidosColumna[num2] = true; 
                    }
                }
            }
    
           
            System.out.println("\nCantidad de números repetidos por fila:");
            for (int fila4 = 0; fila4 < v_fil.length; fila4++) {
                System.out.println("Fila " + (fila4 + 1) + ": " + v_fil[fila4] + " repetidos");
            }
    
           
            System.out.println("\nCantidad de números repetidos por columna:");
            for (int col4 = 0; col4 < v_col.length; col4++) {
                System.out.println("Columna " + (col4 + 1) + ": " + v_col[col4] + " repetidos");
            }
    
        } catch (Exception e) {
            throw new Exception("Ha ocurrido un error en la función Repetidos\n" + e.toString());
        }
    }
    
     //Funciones para el punto número 1.
     public static String[] V_Strings_lleno() throws Exception{ // llenar vector
        try{ 
            //le damos el tamaño al vector
            int alea = (int)(Math.random()* (MAX - MIN + UNO)+MIN);
            v_Strings = new String[alea];
            

            //llenamos el vector con caracteres
            for(int pos = 0; pos < v_Strings.length -3 ; pos++){
                v_Strings[pos] = String.valueOf((char)(Math.random() * (ASCII2 - ASCII1 + UNO)+ASCII1));

            }

            return v_Strings;
            

        } catch (Exception e) {
            throw new Exception("Ocurró un error en el método V_Strings_lleno \n" + e.toString());
        }

     }

     public static int[] V_numeros_lleno() throws Exception{ // llenar vector
        try {
            //le damos el tamaño al vector
            int alea =  (int)(Math.random()* (MAX - MIN + UNO)+MIN);
            v_numeros = new int[alea];

            //llenamos el vector con números enteros
            for(int pos = 0; pos < v_numeros.length -3 ; pos++){
                v_numeros[pos] = (int)(Math.random()* (MAX - MIN + UNO)+MIN);
            }
            
       
        } catch (Exception e) {
            throw new Exception("Ocurró un error en el método V_numeros_lleno \n" + e.toString());
        }

        return v_numeros;

     }

     public static String Recorrer_secuencialmente(String opcion) throws Exception { //Recorrer el vector acendente o decendentemente (inciso a)
        try {
            String txt_s = "";
            String txt_n = "";
            int pos_String, pos_entero;
    
            if(opcion.equals("true")) { // imprimir de manera ascendente
                for(pos_String = 0; pos_String < v_Strings.length; pos_String ++){
                    txt_s += v_Strings[pos_String];
                    txt_s += "\t";
                }
                
                for(pos_entero = 0; pos_entero < v_numeros.length; pos_entero ++){
                    txt_n += v_numeros[pos_entero];
                    txt_n += "\t";
                }
                
                return CYAN + "vector de Strings \n"+ RESET + txt_s + "\n \n" + CYAN + "vector de números \n"+ RESET + txt_n;
            }
            
            else if (opcion.equalsIgnoreCase("false")){
                for(pos_String = v_Strings.length-1; pos_String >= 0; pos_String --){
                    txt_s += v_Strings[pos_String];
                    txt_s += "\t";
                }
                
                for(pos_entero = v_numeros.length-1; pos_entero >= 0; pos_entero --){
                    txt_n += v_numeros[pos_entero];
                    txt_n += "\t";
                }
                
                return CYAN + "vector de Strings \n"+ RESET + txt_s + "\n \n" + CYAN + "vector de números \n"+ RESET + txt_n;
            }
        } catch (Exception e) {
            throw new Exception("Ha ocurrido un error en la función Recorrer secuencialmente \n" + e.toString());
        }
        return "";
    }

     public static String Actualizar(String posicion_s, String posicion_n, String reemplazo_s, String reemplazo_n ) throws Exception {
        try {
            String txt_s = "", txt_n = "";
            int posicion_de_reemplazo_s = Integer.parseInt(posicion_s);
            int posicion_de_reemplazo_n = Integer.parseInt(posicion_n);
            int reemplazo_vnum = Integer.parseInt(reemplazo_n);


            //ciclo for para el vector de Strings
            for(int pos_String = 0; pos_String < v_Strings.length; pos_String++){

                if(pos_String != posicion_de_reemplazo_s){ 
                    txt_s += v_Strings[pos_String];
                    txt_s += "\t";
                }
                else if(pos_String == posicion_de_reemplazo_s){

                    v_Strings[posicion_de_reemplazo_s] = reemplazo_s;
                    txt_s += Purpura + v_Strings[posicion_de_reemplazo_s] + RESET;
                    txt_s += "\t";


                }
            }

            //ciclo for para el vector de números
            for(int pos_entero = 0; pos_entero < v_numeros.length; pos_entero ++){
                
                if(pos_entero != posicion_de_reemplazo_n){ 
                    txt_n += v_numeros[pos_entero];
                    txt_n += "\t";
                    
                }
                else if(pos_entero == posicion_de_reemplazo_n){

                    v_numeros[posicion_de_reemplazo_n] = reemplazo_vnum;
                    txt_n += Purpura +  v_numeros[posicion_de_reemplazo_n] + RESET;
                    txt_n += "\t";

                }

            }

            return CYAN + "Este es el vector de Strings actualizado" + RESET + "\n" + txt_s + "\n\n" + CYAN + "Este es el vector de números actualizado \n" + RESET + txt_n;
        
            


        } catch (Exception e) {
           throw new Exception("Ocurrió un error en la función Actualizar \n" + e.toString());
        }





    }
    
     public static String Añadir(String elemento_s, String elemento_n) throws Exception {
        try {
            int elemento_n_int = Integer.parseInt(elemento_n);
            String txt = "Estos son los dos vectores ya con sus elementos añadidos \n\n";
            
            
            for (int j = 0; j < v_Strings.length; j++) {
                if (v_Strings[j] == null) {
                    v_Strings[j] = elemento_s;
                    j = v_Strings.length;
                    
                }
                
            }
    
            
            for (int i = 0; i < v_numeros.length; i++) {
                if (v_numeros[i] == 0) {
                    v_numeros[i] = elemento_n_int;
                    i = v_numeros.length;
                     
                }
                
            }
    
            txt += CYAN + "Vector de Strings\n" + RESET;
            for (int n = 0; n < v_Strings.length; n++) {
                txt += v_Strings[n] + "\t";
            }

            txt += "\n\n";

            txt += CYAN +"Vector de números\n" + RESET;
            for (int k = 0; k < v_numeros.length; k++) {
                txt += v_numeros[k] + "\t";
            }
           
    
         
            return txt;

    
        } catch (Exception e) {
            throw new Exception("Error en el método Añadir\n " + e.toString());
        }
    }
    
     public static String Borrar (String elemento_s, String elemento_n) throws Exception{
        try {
            int elemento_n_int = Integer.parseInt(elemento_n);
            int elemento_s_int = Integer.parseInt(elemento_s);
            String txt = "Estos son los dos vectores ya con sus elementos eliminados \n\n";
            
           
            for (int j = 0; j < v_Strings.length; j++) {
                if (v_Strings[j].equals(v_Strings[elemento_s_int])) {
                    v_Strings[j] = null;
                    j = v_Strings.length;
                    
                }
                
            }
    
           
            for (int i = 0; i < v_numeros.length; i++) {
                if (v_numeros[i] == v_numeros[elemento_n_int]) {
                    v_numeros[i] = 0;
                    i = v_numeros.length;
                     
                }
                
            }

            txt += CYAN + "Vector de Strings\n" + RESET;
            for (int n = 0; n < v_Strings.length; n++) {
                txt += v_Strings[n] + "\t";
            }

            txt += "\n\n";

            txt += CYAN +"Vector de números\n" + RESET;
            for (int k = 0; k < v_numeros.length; k++) {
                txt += v_numeros[k] + "\t";
            }
           
    
         
            return txt;



        } catch (Exception e) {
            throw new Exception( " Error en la funcion Borrar\n" + e.toString());
        }

        





    }

     public static String Ordenar_Ascendente_Descendente(String opcion) throws Exception {
        try {
            String resultado = "";
            int auxNum1, auxNum2;
            String auxChar1, auxChar2;
    
            for (int i = 0; i < v_numeros.length - 1; i++) {
                for (int j = 0; j < v_numeros.length - 1 - i; j++) {
                    if (v_numeros[j] != 0 && v_numeros[j + 1] != 0) {
                        if (opcion.equals("1") && v_numeros[j] > v_numeros[j + 1]) {
                            auxNum1 = v_numeros[j];
                            v_numeros[j] = v_numeros[j + 1];
                            v_numeros[j + 1] = auxNum1;
                        } else if (opcion.equals("2") && v_numeros[j] < v_numeros[j + 1]) {
                            auxNum2 = v_numeros[j];
                            v_numeros[j] = v_numeros[j + 1];
                            v_numeros[j + 1] = auxNum2;
                        }
                    }
                }
            }
    
            for (int i = 0; i < v_Strings.length - 1; i++) {
                for (int j = 0; j < v_Strings.length - 1 - i; j++) {
                    if (v_Strings[j] != null && v_Strings[j + 1] != null) {
                        if (opcion.equals("1") && v_Strings[j].compareTo(v_Strings[j + 1]) > 0) {
                            auxChar1 = v_Strings[j];
                            v_Strings[j] = v_Strings[j + 1];
                            v_Strings[j + 1] = auxChar1;
                        } else if (opcion.equals("2") && v_Strings[j].compareTo(v_Strings[j + 1]) < 0) {
                            auxChar2 = v_Strings[j];
                            v_Strings[j] = v_Strings[j + 1];
                            v_Strings[j + 1] = auxChar2;
                        }
                    }
                }
            }
    
            resultado +=  CYAN+ "Números"  +":\n" + RESET;
            for (int i = 0; i < v_numeros.length; i++) {
                if (v_numeros[i] != 0) {
                    resultado += v_numeros[i] + "\t";
                }
            }
            resultado +=  CYAN+ "\n\nStrings"  +":\n" + RESET;
            for (int i = 0; i < v_Strings.length; i++) {
                if (v_Strings[i] != null) {
                    resultado += v_Strings[i] + "\t";
                }
            }
            resultado += "\n";
    
            return resultado;
    
        } catch (Exception e) {
            throw new Exception("Error en la función Ordenar\n" + e.toString());
        }
    }
    
    public static String Busqueda(String elemento_s, String elemento_n) throws Exception {
        try {
            int numero = Integer.parseInt(elemento_n);
            String txt = "";
            boolean pertenece_Strings = false;
            boolean pertenece_numeros = false;
            int i = 0;
            int j = 0;
    
            
            for (i = 0; i < v_Strings.length; i++) {
                if (elemento_s == null) {
                    if (v_Strings[i] == null) {
                        pertenece_Strings = true;
                        break;
                    }
                } else if (elemento_s.equals(v_Strings[i])) {
                    pertenece_Strings = true;
                    break;
                }
            }
    
            
            for (j = 0; j < v_numeros.length; j++) {
                if (v_numeros[j] == numero) {
                    pertenece_numeros = true;
                    break;
                }
            }
    
            if (!pertenece_Strings) {
                txt += "El elemento no pertenece al arreglo de Strings, ingrese uno que sí esté en él.";
            } else {
                txt += CYAN + "Para el vector de Strings el elemento se encuentra en la(s) posición(es): " + RESET;
                for (i = 0; i < v_Strings.length; i++) {
                    if (elemento_s == null) {
                        if (v_Strings[i] == null) {
                            txt += i + " - ";
                        }
                    } else if (elemento_s.equals(v_Strings[i])) {
                        txt += i + " - ";
                    }
                }
            }
    
            if (!pertenece_numeros) {
                txt += "\n\nEl elemento no pertenece al arreglo de números, ingrese uno que sí esté en él.";
            } else {
                txt += CYAN + "\n\nPara el vector de números el elemento se encuentra en la(s) posición(es): " + RESET;
                for (j = 0; j < v_numeros.length; j++) {
                    if (v_numeros[j] == numero) {
                        txt += j + " - ";
                    }
                }
            }
            return txt;
    
        } catch (Exception e) {
            throw new Exception("Error en la función de Búsqueda\n" + e.toString());
        }
    }




}   
